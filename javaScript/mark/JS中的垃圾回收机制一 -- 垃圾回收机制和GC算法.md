- ### JS中的内存管理
  
内存，是由可读写单元组成，表示一片可操作性的空间。我们平常创建基本类型，对象，数组等都需要内存。既然有使用就会有管理。js中的内存管理分为三步：1. 申请内存空间， 2. 使用内存空间，3. 释放内存空间。

JS中的内存管理是自动的，我们创建基本类型，对象，数组时就会自动分配内存空间。当对象不再被引用或者对象不能从跟上访问到时即变为垃圾。所以垃圾回收机制中的垃圾指的就是这些对象，回收的就是它们所占用的内存空间。

- ### JS的可达对象

JS的内存管理的一个重要概念就是对象的可达性。
可达对象简单来说就是可以访问到的对象就是可大对象，这个对象不管是通过引用还是通过作用域链，只要是可以访问到那就是可达的。
而可达的标准就是从根出发是否能够被找到，这里的根可以理解为全局变量对象(全局执行上下文)

- ### GC算法
GC就是垃圾回收机制的简写，GC可以找到内存中的垃圾，并释放和回收空间。算法就是工作时查找和回收所遵循的规则

常见的GC算法有 ： 
  - 引用计数
  - 标记清除
  - 标记整理
  - 分代回收

 #### - 引用计数
##### 实现
 给每个对象添加一个计数器，标识对象的引用次数，当一个新引用指向对象时计数器加1，当指向对象的引用失效时计数器减1.当计数器值为0时会被立即回收。
##### 优缺点
优点 ：
  - 发现垃圾时立即回收
  - 最大限度减少程序暂停

缺点 ：
  - 无法回收循环引用的对象
  - 时间开销大

这里循环引用就是有两个对象互相引用，举例说明
```
  function fn() {
    const obj1 = {}
    const obj2 = {}
    //全局作用域下找不到obj1，obj2，但是obj1.name,obj2.name还引用着，所以引用数不为0
    obj1.name = obj2;
    obj2.name = obj1

    return 'xxxx'
}
fn()
```

#### - 标记清除
##### 实现
  标记清除分为标记和清除两个阶段完成
    1. 遍历所有对象找标记活动对象
    2. 遍历所有对象清除没有标记对象

标记计数时会递归的查找引用层级关系，把可达对象进行标记。
标记清除将回收的空间放在空闲列表上面，方便后面的程序直接在这里申请内存使用。

##### 优缺点

- 优点 
  解决对象循环引用不能回收的问题(相对于引用计数)

- 缺点
  1. 空间碎片化（由于回收的空间地址不连续），不能使空间最大化使用
  2. 不会立即清除垃圾

##### - 标记整理
标记整理算法是标记清除算法的一个升级。主要是为了减少碎片空间化。工作原理与标记清除算法相同。
- 标记阶段 ： 遍历所有对象，把可达对象都打上一个标记。

- 清除阶段 ： 遍历堆中所有对象，没有被标记的对象会被清除。在这之前，这些对象会被移动位置，也就是先进行整理，把这些对象位置移动到一起后再清理。这样就减少了碎片化空间。

